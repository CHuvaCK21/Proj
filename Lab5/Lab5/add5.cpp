#include "../../Proj/Fn.h"
#include <iostream>
#include <iomanip>
#include <fstream>
#include <locale.h>

bool Kniga::operator <(Kniga &name2) { //Тело перегрузки оператора <
	if (name < name2.name) { //Сравнивание двух имен
		return true; //Возвращаем true если результат положительный
	}
	else {
		return false; //Иначе возвращаем false
	}
}
bool Kniga::operator<=(const char &a) { //Тело перегрузки оператора <=
	if (name[0] <= a) { //Если первый символ попал в диапозон
		return true; //То возвращаем true
	}
	else {
		return false; //Иначе false
	}
}

bool Kniga::operator>=(const char &a) { //Тело перегрузки оператора >=
	if (name[0] >= a) { //Если первый символ попал в диапозон
		return true; //То возвращаем true
	}
	else {
		return false; //Иначе false
	}
}

void Kniga::operator-(const int &n) { //Тело перегрузки оператора -
	name[0] = name[0] - n; //Вычитаем n
}

void Kniga::search(string ser, vector<Kniga> let, vector<Kniga> *let2) {
	vector<Kniga>::iterator a = let2->begin(); 
	int top = 0; //Переменная хранит индекс 1 элемента
	int bottom = let.size() - 1; //Переменная, которая хранит индекс самого последнего элемента
	int mid = (top + bottom) / 2; //Середина записной книжки
	for (int i = 0; ser[i] != '\0'; i++) { //Замена всех больших букв на маленькие
		if (ser[i] >= 65 && ser[i] <= 90) { //Если число попадает в диапазон
			ser[i] = ser[i] + 32; //То прибавляем 32, чтобы получить маленькую букву
		}
	}
	for (vector<Kniga>::iterator j = let.begin(); j != let.end(); j++) { //Цикл прохода по вектору
		for (unsigned int i = 0; i < j->name.size(); i++) { //Пока не дойдем до конца строки
			if (j->name[i] >= 65 && j->name[i] <= 90) { //Если попадает число в диапазон
				j->name[i] = j->name[i] + 32; //То прибавляем 32 и получаем маленькую букву
			}
		}
	}
	do { //Цикл для поиска слов методом дихотомии
		if (let[mid].name == ser) { //Если середина равна тому, что ищем, то выводим на экран
			cout << a[mid].name << "\t\t\t";
			cout << (let[mid].plus ? "+" : " ");
			cout << let[mid].num;
			break; //Поиск завершен, прерывание цикла
		}
		else if (let[mid].name > ser){ //Если число в середине больше чем искомое, то ищем в первой половине списка
			bottom = mid; //Сдвигает верхний край
			mid = (top + bottom) / 2; //Находим новую середину в первой половине
		}
		else {
			mid++; //Сдвиг середины на 1
			top = mid; //Начало нового интервала будет теперь бывшая середина
			mid = (top + bottom) / 2; //Находим новую середину сложив начало нового интервала с последним элементом и поделив на 2
		}
		if ((bottom - top) == 0 && let[mid].name != ser) {
			cout << "Ничего не найдено"; //Уведомляем, что ничего не найдено
			break; //Прерываем цикл
		}
	} while (true); //Пока цикл не прервали break
}

int Kniga::write2(unsigned int *c) {
	int f = 0; //Переменная для проверки на наличие ошибок при вводе номера телефона
	cout << "Введите имя: "; //Вывод на экран запроса вывода имени абонента
	cin >> name; //Команда ввода имени
	*c = size(name); //Количеством символов в имени для выравнивания в таблице
	if((f = write()) == -2) { //Приравниваем переменной f результат выполнения функции write(), если -2, значит номер телефона слишком длинный
		do{
			cout << "Вы ввели недопустимо длинный номер, введите имя абонента заново."<<endl; //Вывод сообщения, что длинный номер
			cin >> name; //Повторный запрос ввода имени
			*c = size(name); //Также повторная запись количества символов в переменную c
			f = write(); //Повторный вызов функции записи номера телефона с записью результата в f
		} while (f == -2); //Пока пользователь не введет номер телефона нужной длинны, будет требоваться ввести повторно имя абонента
	}else if (f == -1) { //Если функция вернула значение -1, то идет возврат -1, что означает, что пользователь ввел 0 в номере телефона
		return -1; // Возврат -1
	}
	else if (f == 0) { //Если функция вернула 0, значит все хорошо и можно продолжать ввод номеров телефонов
		return 0; //Возврат 0
	}
	return 0;
}

void Kniga::print(int *ch) {
	ofstream f; //Объявление объекта класса
	f.open("NUMBERS.txt", ios::app); //Открытие файл с параметром app для записи в конец файла без стирания предыдущей информации
	cout <<"   " << name; //Вывод имени
	f << "  "<<name; //Запись имени в файл с пробелом
	for (unsigned int i = 0; i < *ch - size(name); i++) { //Выравнивание по ширине по количеству символов в имени
		cout << " "; //Печать пробелов для удобства
		f << " "; //Запись пробелов в файл
	}
	for (int i = 0; i < 24-*ch; i++) { //Печать через 24-*ch пробелов номеров телефонов
		cout << " "; //Печать пробелов
		f << " "; //Запись пробелов в файл
	}
	cout << (plus ? "+" : " ");//Вывод знака + или пробела если в plus записано 1 или 0
	f << (plus ? "+" : " "); //Запись знака + в файл
	cout <<num << endl; //Вывод номера телефона
	f << num<<endl; //Запись номера телефона в файл
	f.close(); //Закрытие файла
}

int Kniga::write() {
	string a, b(50, ' '); //Строки для записи в них номеров телефонов
	unsigned int c[100] = {}; //Массив для записи количества цифр в номере телефона
	cin.ignore(numeric_limits<streamsize>::max(), '\n'); //Очистка буфера ввода, была узнана путем поиска на просторах интернета
	cout << "Введите номер: "; //Запрос ввода номера
	cin>>a; //Команда для ввода номера телефона
	if (a[0] == '0') { //Если первый символ 0, то возвращаем -1 
		return -1;
	}
	else if (a[0] == '+') { //Если первый символ +, то проверку строки начинаем со второго элемента массива 
		if (CheckStr(&a[1], &b[0], c) == 0) { //Если функция проверки строки равна 0, то значит превышения количества символов в номере не было
			plus = 1; //Приравниваем переменной значение 1 т.к первым элементом был + 
			num = atoll(&b[0]); //Перевод в int нашего очищенного массива номера телефона
			return 0; //Возврат 0 т.к 
		}
		else {
			return -2; //Возврат -2 в случае если превышено количество символов
		}
	}
	else {
		if (CheckStr(&a[0], &b[0], c) == 0) { //Если первый символ не +, то проводим проверку строки с номером телефона с 1 элемента
			plus = 0; //Приравнивание 0 т.к символа плюс было не обнаружено
			num = atoll(&b[0]); //Перевод очищенного и проверенного числа в десятичный вид
			return 0; //Возврат 0
		}
		else {
			return -2; //Возврат -2 в случае если превышено количество символов
		}
	}
}

int sort(vector<Kniga> &let) {
	int srav = 0; //Переменные счета
	for (unsigned int i = 0; i < let.size(); i++) { //Меняем первые буквы на заглавные если они являются маленькими
		if (let[i] >= 97 && let[i] <= 122) { //Если первый символ принадлежит диапазону
			let[i] - 32; //То вычитаем 32 из символа, получая заглавную букву
		}
	}
	for (unsigned int s = 0; s < let.size(); s++) { //Проход по циклу соразмерно размеру массива
		for (unsigned int g = let.size()-1; g > 0; g--) { //Проходим весь массив с конца не доходя до первого элемента
			srav++; //Прибавляем 1 т.к произошло сравнение
			if (let[g] < let[g-1]) { //Сравнение имен, при удовлетворительном исполнение меняем имена местами
				swap(let[g-1], let[g]); //Замена двух элементов динамического массива местами друг с другом
			}
		}
	}
	return srav; //Возврат количества сравнений для вывода на экран
}