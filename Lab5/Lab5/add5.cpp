#include "../../Proj/Fn.h"
#include <iostream>
#include <iomanip>
#include <fstream>
#include <locale.h>

void Kniga::search(string ser, vector<Kniga> let, vector<Kniga> *let2) {
	vector<Kniga>::iterator j = let.begin();
	vector<Kniga>::iterator a = let2->begin();
	for (int i = 0; ser[i] != '\0'; i++) {
		if (ser[i] >= 65 && ser[i] <= 90) {
			ser[i] = ser[i] + 32;
		}
	}
	j = let.begin();
	for (; j != let.end(); j++) {
		for (int i = 0; j->name[i] != '\0'; i++) {
			if (j->name[i] >= 65 && j->name[i] <= 90) {
				j->name[i] = j->name[i] + 32;
			}
		}
	}
	j = let.begin();
	for (; j != let.end(); j++, a++) {	
		if (ser == j->name) {
			cout << a->name<<"\t\t\t";
			cout << (j->plus ? "+" : " ");
			cout << j->num;
		}
	}
}

int Kniga::write2(unsigned int *c) {
	int f = 0; //Переменная для проверки на наличие ошибок при вводе номера телефона
	cout << "Введите имя: "; //Вывод на экран запроса вывода имени абонента
	cin >> name; //Команда ввода имени
	*c = size(name); //Количеством символов в имени для выравнивания в таблице
	if((f = write()) == -2) { //Приравниваем переменной f результат выполнения функции write(), если -2, значит номер телефона слишком длинный
		do{
			cout << "Вы ввели недопустимо длинный номер, введите имя абонента заново."<<endl; //Вывод сообщения, что длинный номер
			cin >> name; //Повторный запрос ввода имени
			*c = size(name); //Также повторная запись количества символов в переменную c
			f = write(); //Повторный вызов функции записи номера телефона с записью результата в f
		} while (f == -2); //Пока пользователь не введет номер телефона нужной длинны, будет требоваться ввести повторно имя абонента
	}else if (f == -1) { //Если функция вернула значение -1, то идет возврат -1, что означает, что пользователь ввел 0 в номере телефона
		return -1; // Возврат -1
	}
	else if (f == 0) { //Если функция вернула 0, значит все хорошо и можно продолжать ввод номеров телефонов
		return 0; //Возврат 0
	}
	return 0;
}

void Kniga::print(int *ch) {
	ofstream f;
	f.open("NUMBERS.txt", ios::app);
	cout <<"   " << name; //Вывод имени
	f << "  "<<name;
	for (unsigned int i = 0; i < *ch - size(name); i++) { //Выравнивание по ширине по количеству символов в имени
		cout << " "; //Печать пробелов для удобства
		f << " ";
	}
	for (int i = 0; i < 24-*ch; i++) { //Печать через 24=*ch пробелов номеров телефонов
		cout << " "; //Печать пробелов
		f << " ";
	}
	cout << (plus ? "+" : " ");//Вывод знака + или пробела если в plus записано 1 или 0
	f << (plus ? "+" : " ");
	cout <<num << endl; //Вывод номера телефона
	f << num<<endl;
	f.close();
}

int Kniga::write() {
	string a, b(50, ' '); //Строки для записи в них номеров телефонов
	unsigned int c[100] = {}; //Массив для записи количества цифр в номере телефона
	cin.ignore(numeric_limits<streamsize>::max(), '\n'); //Очистка буфера ввода, была узнана путем поиска на просторах интернета
	cout << "Введите номер: "; //Запрос ввода номера
	cin>>a; //Команда для ввода номера телефона
	if (a[0] == '0') { //Если первый символ 0, то возвращаем -1 
		return -1;
	}
	else if (a[0] == '+') { //Если первый символ +, то проверку строки начинаем со второго элемента массива 
		if (CheckStr(&a[1], &b[0], c) == 0) { //Если функция проверки строки равна 0, то значит превышения количества символов в номере не было
			plus = 1; //Приравниваем переменной значение 1 т.к первым элементом был + 
			num = atoll(&b[0]); //Перевод в int нашего очищенного массива номера телефона
			return 0; //Возврат 0 т.к 
		}
		else {
			return -2; //Возврат -2 в случае если превышено количество символов
		}
	}
	else {
		if (CheckStr(&a[0], &b[0], c) == 0) { //Если первый символ не +, то проводим проверку строки с номером телефона с 1 элемента
			plus = 0; //Приравнивание 0 т.к символа плюс было не обнаружено
			num = atoll(&b[0]); //Перевод очищенного и проверенного числа в десятичный вид
			return 0; //Возврат 0
		}
		else {
			return -2; //Возврат -2 в случае если превышено количество символов
		}
	}
}

int Kniga::sort(vector<Kniga> *let) {
	int srav = 0; //Переменные счета
	string copy; //Строка для копий данных
	unsigned long long temp1, temp2; //Строка для копий данных
	vector<Kniga>::iterator h = let->begin(); //Объявление и инициализация итератора динамического массива
	for (; h != let->end(); h++) { //Меняем первые буквы на заглавные если они являются маленькими
		if (h->name[0] >= 97 && h->name[0] <= 122) { //Если первый символ принадлежит диапазону
			h->name[0] = (h->name[0] - 32); //То вычитаем 32 из символа, получая заглавную букву
		}
	}
	h = let->begin(); //Снова приравниваем нашему итератору начало массива
	for (unsigned int s = 0; s < let->size() - 1; s++) { //Проход по циклу соразмерно размеру массива-1 
		for (unsigned int g = 1, c = 0; g < let->size()-s; c++, g++) { //Проходим весь массив, вычитая последние n элементов сравнивая каждое имя
			srav++; //Прибавляем 1 т.к произошло сравнение
			if (h[c].name > h[g].name) { //Сравнение имен, при удовлетворительном исполнение меняем имена местами
				copy = h[g].name; //Цикл проверяет замененное слово со следующим до тех пор пока не опустит в самый низ низшее по алфавиту имя
				temp1 = h[g].num;		//Это все операции
				temp2 = h[g].plus;		//Для замены переменных
				h[g].name = h[c].name;	//Местами
				h[g].num = h[c].num;	//Первое значение сохраняем в копию
				h[g].plus = h[c].plus;	//В первое записываем второе
				h[c].name = copy;		//И уже во второе записываем нашу копию
				h[c].num = temp1;		//Как в итоге получаем замененные местами:
				h[c].plus = temp2;		//Имя, номер телефона и знак плюс
			}
		}
	}
	return srav; //Возврат количества сравнений для вывода на экран
}